# -*- coding: utf-8 -*-
"""CODIGO FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TD0UKbWupsv2tDwsDJA_lqTUNi_6nCzk

# ***1. Pre-Procesamiento de los datos del sensor***

IMPORTACIÓN DE LIBRERIAS
"""

# Commented out IPython magic to ensure Python compatibility.
#Librerias
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# %matplotlib inline
import numpy as np

"""IMPORTACIÓN DE LOS DATOS BRUTOS BRINDADOS POR EL SENSOR"""

from google.colab import drive
drive.mount("/content/drive/")

# Especifica la ruta de los datos y el tipo de datos deseado para la columna "Time"
data = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/SENSOR 60KM MAURICIO PRUEBA 3.csv")

# Imprime los datos
print(data)

"""FILTRACIÓN DE LOS TIEMPOS NECESARIOS"""

# Convertir la columna 'Time' a un formato de tiempo
data['Time'] = pd.to_datetime(data['Time'], format='%M:%S.%f')

# Definir los límites de tiempo
start_time = pd.to_datetime('44:46.0', format='%M:%S.%f')
end_time = pd.to_datetime('47:52.9', format='%M:%S.%f')

# Filtrar el dataframe
data_filtrado = data[(data['Time'] >= start_time) & (data['Time'] <= end_time)]

# Ajustar el formato de la columna 'Time'
data_filtrado['Time'] = data_filtrado['Time'].apply(lambda x: '20:' + x.strftime('%M:%S.%f')[:-5])

# Mostrar el dataframe filtrado
print(data_filtrado)

"""ELIMINACIÓN DE VALORES NULOS"""

columns_to_check = [
    'AccX(g)', 'AccY(g)', 'AccZ(g)',
    'GyroX(°/s)', 'GyroY(°/s)', 'GyroZ(°/s)',
    'AngleX(°)', 'AngleY(°)', 'AngleZ(°)'
]
# Eliminar filas que contienen NaNs en las columnas especificadas
df_cleaned = data_filtrado.dropna(subset=columns_to_check)

# Mostrar un resumen del DataFrame limpio para confirmar
print(df_cleaned.info())
print(df_cleaned.head())

# Si deseas imprimir todo el DataFrame limpio:
print(df_cleaned)

"""FILTRACIÓN DE LAS COLUMNAS DESEADAS"""

# ORGANIZAR LOS NOMBRES DE LO QUE QUEREMOS QUE APAREZCA TAL CUAL ESTE EN EL EXCEL, DE LO CONTRARIO NO FUNCIONARA
columnas_deseadas = ['Time','DeviceName', 'AngleX(°)', 'AngleY(°)', 'AngleZ(°)',  'AccX(g)', 'AccY(g)', 'AccZ(g)']

# Verificar si las columnas deseadas están presentes en el DataFrame
for col in columnas_deseadas:
    if col not in df_cleaned.columns:
        print(f"La columna '{col}' no se encuentra en el DataFrame")

# Seleccionar las columnas deseadas si todas están presentes
if all(col in df_cleaned.columns for col in columnas_deseadas):
    df_filtrado = df_cleaned.loc[:, columnas_deseadas]
    # Mostrar el nuevo DataFrame con las columnas seleccionadas
    print(df_filtrado)
else:
    print("Algunas columnas deseadas no se encuentran en el DataFrame.")

"""SEPARACIÓN DE SENSORES"""

# Aquí se incluye una pequeña comprobación adicional para ver las primeras filas antes de cualquier operación
print("Primeras filas del DataFrame original:")
print(df_filtrado.head())

# Extraer el valor base de DeviceName
df_filtrado['DeviceBase'] = df_filtrado['DeviceName'].str.extract(r'(WTC\d)', expand=False)

# Verificar los valores únicos de DeviceBase después de la extracción
print("Valores únicos en 'DeviceBase':")
print(df_filtrado['DeviceBase'].unique())

# Filtrar por cada sensor y crear DataFrames separados
df_WTC1 = df_filtrado[df_filtrado['DeviceBase'] == 'WTC1']
df_WTC2 = df_filtrado[df_filtrado['DeviceBase'] == 'WTC2']
df_WTC3 = df_filtrado[df_filtrado['DeviceBase'] == 'WTC3']

# Verificar el contenido de cada DataFrame filtrado
print("Contenido de df_WTC1:")
print(df_WTC1)
print("Contenido de df_WTC2:")
print(df_WTC2)
print("Contenido de df_WTC3:")
print(df_WTC3)

# Guardar los DataFrames en un archivo Excel con hojas separadas
#with pd.ExcelWriter('sensores_datasets.xlsx') as writer:
    #df_WTC1.to_excel(writer, sheet_name='WTC1', index=False)
    #df_WTC2.to_excel(writer, sheet_name='WTC2', index=False)
    #df_WTC3.to_excel(writer, sheet_name='WTC3', index=False)

# Confirmar que los datos se han guardado correctamente
#print("DataFrames guardados en sensores_datasets.xlsx")

"""**SENSOR 1**

CALCULO DEL PROMEDIO DE ACELERACIÓN
"""

# Comprobar si ya existe una fila con "Average" en la columna 'Time'
if 'Average' not in df_WTC1['Time'].values:
    # Calcular los promedios de las columnas 'AccX(g)', 'AccY(g)', 'AccZ(g)'
    mean_AccX = df_WTC1['AccX(g)'].mean()
    mean_AccY = df_WTC1['AccY(g)'].mean()
    mean_AccZ = df_WTC1['AccZ(g)'].mean()

    # Crear las nuevas columnas con la resta de cada valor con respecto al promedio
    df_WTC1['ACC X PROM'] = df_WTC1['AccX(g)'] - mean_AccX
    df_WTC1['ACC Y PROM'] = df_WTC1['AccY(g)'] - mean_AccY
    df_WTC1['ACC Z PROM'] = df_WTC1['AccZ(g)'] - mean_AccZ

    # Crear un diccionario con los valores promedio
    average_row = {
        'Time': 'Average',
        'DeviceName': '',
        'AngleX(°)': '',
        'AngleY(°)': '',
        'AngleZ(°)': '',
        'AccX(g)': mean_AccX,
        'AccY(g)': mean_AccY,
        'AccZ(g)': mean_AccZ,
        'DeviceBase': '',
        'ACC X PROM': 0,
        'ACC Y PROM': 0,
        'ACC Z PROM': 0
    }

    # Convertir el diccionario a un DataFrame
    average_df = pd.DataFrame(average_row, index=[0])

    # Añadir la fila promedio al final del DataFrame original
    df_WTC1 = pd.concat([df_WTC1, average_df], ignore_index=True)

# Mostrar las últimas filas del DataFrame para verificar
print(df_WTC1.head(60))


# Guardar los DataFrames en un archivo Excel con hojas separadas
with pd.ExcelWriter('sensores_datasets.xlsx') as writer:
    df_WTC1.to_excel(writer, sheet_name='WTC1', index=False)

"""ELIMINACIÓN DE LAS CENTÉSIMAS"""

import re

# Remove all decimals from "Time"
df_WTC1["Time"] = df_WTC1["Time"].apply(lambda x: re.sub(r"\.\d*", "", x))

numeric_columns = ['AngleX(°)', 'AngleY(°)','AngleZ(°)', 'ACC X PROM', 'ACC Y PROM', 'ACC Z PROM']

# Convertir las columnas numéricas a tipo float para promediar
for col in numeric_columns:
    df_WTC1[col] = pd.to_numeric(df_WTC1[col], errors='coerce')

# Agrupar por 'Time' y tomar el primer valor de 'DeviceName', promediar los valores numéricos
df_promedio_por_segundoWT1 = df_WTC1.groupby('Time').agg({
    'DeviceName': 'first',  # Tomar el primer valor de DeviceName en cada grupo
    'AngleX(°)': 'mean',    # Promediar los valores numéricos
    'AngleY(°)': 'mean',
    'AngleZ(°)': 'mean',
    'ACC X PROM': 'mean',
    'ACC Y PROM': 'mean',
    'ACC Z PROM': 'mean'
}).reset_index()

# Imprimir el DataFrame agrupado y promediado
print(df_promedio_por_segundoWT1)

"""AJUSTE  DE ÁNGULO"""

# Sumar a las columnas AngleX, AngleY y AngleZ
df_promedio_por_segundoWT1['AngleX(°)'] -= 0.044
df_promedio_por_segundoWT1['AngleY(°)'] -= 0.198
df_promedio_por_segundoWT1['AngleZ(°)'] -= 70.724

# Guardar el DataFrame modificado en un nuevo archivo CSV
df_promedio_por_segundoWT1.to_csv('tu_dataset_modificado.csv', index=False)

print("Valores actualizados en las columnas AngleX, AngleY y AngleZ:")
print(df_promedio_por_segundoWT1)

"""GRÁFICO DE LAS ACELERACIONES EN EL TIEMPO"""

# Crear una figura de mayor tamaño
plt.figure(figsize=(20, 9))

# Graficar ACC X PROM
plt.plot(df_promedio_por_segundoWT1['Time'], df_promedio_por_segundoWT1['ACC X PROM'], label='ACC X PROM')

# Graficar ACC Y PROM
plt.plot(df_promedio_por_segundoWT1['Time'], df_promedio_por_segundoWT1['ACC Y PROM'], label='ACC Y PROM')

# Graficar ACCZ PROM
plt.plot(df_promedio_por_segundoWT1['Time'], df_promedio_por_segundoWT1['ACC Z PROM'], label='ACC Z PROM')

# Configuración de la gráfica
plt.xlabel('Time')
plt.ylabel('Value')
plt.title('ACC Promedio por segundo')
plt.legend()
plt.xticks(rotation=45)  # Rotar etiquetas del eje X para mejor visualización
plt.gca().set_xticks( df_promedio_por_segundoWT1['Time'][::5])  # Establecer marcas cada 5 segundos

# Mostrar la gráfica
plt.tight_layout()  # Ajustar márgenes
plt.show()

"""IDENTIFICAR PERIODOS DE ACELERACIÓN E INCLINACIÓN"""

# Definir función para identificar períodos de aceleración, desaceleración e inclinación
def identificar_rangos(df_promedio_por_segundoWT1):
    acelerando = (df_promedio_por_segundoWT1['ACC X PROM'] > 0)
    desacelerando = (df_promedio_por_segundoWT1['ACC X PROM'] < 0)

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT1.loc[acelerando, 'Categoria'] = 'Acelerando'
    df_promedio_por_segundoWT1.loc[desacelerando, 'Categoria'] = 'Desaceleración'

    Derecha = (df_promedio_por_segundoWT1['AngleX(°)'] > 2)
    Izquierda = (df_promedio_por_segundoWT1['AngleX(°)'] < -2)
    Nivelado = ((df_promedio_por_segundoWT1['AngleX(°)'] >= -2) & (df_promedio_por_segundoWT1['AngleX(°)'] <= 2))

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT1.loc[Derecha, 'GIRO'] = 'Derecha'
    df_promedio_por_segundoWT1.loc[Izquierda, 'GIRO'] = 'Izquierda'
    df_promedio_por_segundoWT1.loc[Nivelado, 'GIRO'] = 'Nivelado'
    return df_promedio_por_segundoWT1

# Aplicar la función a nuestro DataFrame
df_promedio_por_segundo_categoriasWT1 = identificar_rangos(df_promedio_por_segundoWT1)


df_promedio_por_segundo_categoriasWT1.reset_index(drop=True, inplace=True)
df_promedio_por_segundo_categoriasWT1.index =df_promedio_por_segundo_categoriasWT1.index + 1

# Mostrar el DataFrame con las categorías identificadas
print(df_promedio_por_segundo_categoriasWT1)

"""**SENSOR 2**

CALCULO DEL PROMEDIO DE ACELERACIÓN
"""

# Comprobar si ya existe una fila con "Average" en la columna 'Time'
if 'Average' not in df_WTC2['Time'].values:
    # Calcular los promedios de las columnas 'AccX(g)', 'AccY(g)', 'AccZ(g)'
    mean_AccX = df_WTC2['AccX(g)'].mean()
    mean_AccY = df_WTC2['AccY(g)'].mean()
    mean_AccZ = df_WTC2['AccZ(g)'].mean()

    # Crear las nuevas columnas con la resta de cada valor con respecto al promedio
    df_WTC2['ACC X PROM'] = df_WTC2['AccX(g)'] - mean_AccX
    df_WTC2['ACC Y PROM'] = df_WTC2['AccY(g)'] - mean_AccY
    df_WTC2['ACC Z PROM'] = df_WTC2['AccZ(g)'] - mean_AccZ

    # Crear un diccionario con los valores promedio
    average_row = {
        'Time': 'Average',
        'DeviceName': '',
        'AngleX(°)': '',
        'AngleY(°)': '',
        'AngleZ(°)': '',
        'AccX(g)': mean_AccX,
        'AccY(g)': mean_AccY,
        'AccZ(g)': mean_AccZ,
        'DeviceBase': '',
        'ACC X PROM': 0,
        'ACC Y PROM': 0,
        'ACC Z PROM': 0
    }

    # Convertir el diccionario a un DataFrame
    average_df = pd.DataFrame(average_row, index=[0])

    # Añadir la fila promedio al final del DataFrame original
    df_WTC2 = pd.concat([df_WTC2, average_df], ignore_index=True)

# Mostrar las últimas filas del DataFrame para verificar
print(df_WTC2)

"""ELIMINACIÓN DE CENTÉSIMAS EN LA COLUMNA TIME"""

# Remove all decimals from "Time"
df_WTC2["Time"] = df_WTC2["Time"].apply(lambda x: re.sub(r"\.\d*", "", x))

numeric_columns = ['AngleX(°)', 'AngleY(°)','AngleZ(°)', 'ACC X PROM', 'ACC Y PROM', 'ACC Z PROM']

# Convertir las columnas numéricas a tipo float para promediar
for col in numeric_columns:
    df_WTC2[col] = pd.to_numeric(df_WTC2[col], errors='coerce')

# Agrupar por 'Time' y tomar el primer valor de 'DeviceName', promediar los valores numéricos
df_promedio_por_segundoWT2 = df_WTC2.groupby('Time').agg({
    'DeviceName': 'first',  # Tomar el primer valor de DeviceName en cada grupo
    'AngleX(°)': 'mean',    # Promediar los valores numéricos
    'AngleY(°)': 'mean',
    'AngleZ(°)': 'mean',
    'ACC X PROM': 'mean',
    'ACC Y PROM': 'mean',
    'ACC Z PROM': 'mean'
}).reset_index()

# Imprimir el DataFrame agrupado y promediado
print(df_promedio_por_segundoWT2)

"""AJUSTE DE LOS ÁNGULOS"""

# Sumar 0.5 a las columnas AngleX, AngleY y AngleZ
df_promedio_por_segundoWT2['AngleX(°)'] -= 0.67
df_promedio_por_segundoWT2['AngleY(°)'] -= 0.044
df_promedio_por_segundoWT2['AngleZ(°)'] -= 38.87

# Guardar el DataFrame modificado en un nuevo archivo CSV
df_promedio_por_segundoWT2.to_csv('tu_dataset_modificado.csv', index=False)

print("Valores actualizados en las columnas AngleX, AngleY y AngleZ:")
print(df_promedio_por_segundoWT2)

"""GRÁFICO DE ACELERACIONES EN EL TIEMPO"""

# Crear una figura de mayor tamaño
plt.figure(figsize=(20, 9))

# Graficar ACC X PROM
plt.plot(df_promedio_por_segundoWT2['Time'], df_promedio_por_segundoWT2['ACC X PROM'], label='ACC X PROM')

# Graficar ACC Y PROM
plt.plot(df_promedio_por_segundoWT2['Time'], df_promedio_por_segundoWT2['ACC Y PROM'], label='ACC Y PROM')

# Graficar ACCZ PROM
plt.plot(df_promedio_por_segundoWT2['Time'], df_promedio_por_segundoWT2['ACC Z PROM'], label='ACC Z PROM')

# Configuración de la gráfica
plt.xlabel('Time')
plt.ylabel('Value')
plt.title('ACC Promedio por segundo')
plt.legend()
plt.xticks(rotation=45)  # Rotar etiquetas del eje X para mejor visualización
plt.gca().set_xticks( df_promedio_por_segundoWT2['Time'][::5])  # Establecer marcas cada 5 segundos

# Mostrar la gráfica
plt.tight_layout()  # Ajustar márgenes
plt.show()

"""IDENTIFICAR PERIODOS DE ACELERACIÓN E INCLINACIÓN"""

# Definir función para identificar períodos de aceleración, desaceleración e inclinación
def identificar_rangos(df_promedio_por_segundoWT2):
    acelerando = (df_promedio_por_segundoWT2['ACC X PROM'] > 0)
    desacelerando = (df_promedio_por_segundoWT2['ACC X PROM'] < 0)

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT2.loc[acelerando, 'Categoria'] = 'Acelerando'
    df_promedio_por_segundoWT2.loc[desacelerando, 'Categoria'] = 'Desaceleración'

    Derecha = (df_promedio_por_segundoWT2['AngleX(°)'] > 2)
    Izquierda = (df_promedio_por_segundoWT2['AngleX(°)'] < -2)
    Nivelado = ((df_promedio_por_segundoWT2['AngleX(°)'] >= -2) & (df_promedio_por_segundoWT2['AngleX(°)'] <= 2))

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT2.loc[Derecha, 'GIRO'] = 'Derecha'
    df_promedio_por_segundoWT2.loc[Izquierda, 'GIRO'] = 'Izquierda'
    df_promedio_por_segundoWT2.loc[Nivelado, 'GIRO'] = 'Nivelado'
    return df_promedio_por_segundoWT2

# Aplicar la función a nuestro DataFrame
df_promedio_por_segundo_categoriasWT2 = identificar_rangos(df_promedio_por_segundoWT2)


df_promedio_por_segundo_categoriasWT2.reset_index(drop=True, inplace=True)
df_promedio_por_segundo_categoriasWT2.index =df_promedio_por_segundo_categoriasWT2.index + 1

# Mostrar el DataFrame con las categorías identificadas
print(df_promedio_por_segundo_categoriasWT2)

"""**SENSOR 3**

CALCULO DEL PROMEDIO DE ACELERACIÓN
"""

# Comprobar si ya existe una fila con "Average" en la columna 'Time'
if 'Average' not in df_WTC3['Time'].values:
    # Calcular los promedios de las columnas 'AccX(g)', 'AccY(g)', 'AccZ(g)'
    mean_AccX = df_WTC3['AccX(g)'].mean()
    mean_AccY = df_WTC3['AccY(g)'].mean()
    mean_AccZ = df_WTC3['AccZ(g)'].mean()

    # Crear las nuevas columnas con la resta de cada valor con respecto al promedio
    df_WTC3['ACC X PROM'] = df_WTC3['AccX(g)'] - mean_AccX
    df_WTC3['ACC Y PROM'] = df_WTC3['AccY(g)'] - mean_AccY
    df_WTC3['ACC Z PROM'] = df_WTC3['AccZ(g)'] - mean_AccZ

    # Crear un diccionario con los valores promedio
    average_row = {
        'Time': 'Average',
        'DeviceName': '',
        'AngleX(°)': '',
        'AngleY(°)': '',
        'AngleZ(°)': '',
        'AccX(g)': mean_AccX,
        'AccY(g)': mean_AccY,
        'AccZ(g)': mean_AccZ,
        'DeviceBase': '',
        'ACC X PROM': 0,
        'ACC Y PROM': 0,
        'ACC Z PROM': 0
    }

    # Convertir el diccionario a un DataFrame
    average_df = pd.DataFrame(average_row, index=[0])

    # Añadir la fila promedio al final del DataFrame original
    df_WTC3 = pd.concat([df_WTC3, average_df], ignore_index=True)

# Mostrar las últimas filas del DataFrame para verificar
print(df_WTC3)

""" ELIMINACIÓN DE CENTÉSIMAS"""

# Remove all decimals from "Time"
df_WTC3["Time"] = df_WTC3["Time"].apply(lambda x: re.sub(r"\.\d*", "", x))

numeric_columns = ['AngleX(°)', 'AngleY(°)','AngleZ(°)', 'ACC X PROM', 'ACC Y PROM', 'ACC Z PROM']

# Convertir las columnas numéricas a tipo float para promediar
for col in numeric_columns:
    df_WTC3[col] = pd.to_numeric(df_WTC3[col], errors='coerce')

# Agrupar por 'Time' y tomar el primer valor de 'DeviceName', promediar los valores numéricos
df_promedio_por_segundoWT3 = df_WTC3.groupby('Time').agg({
    'DeviceName': 'first',  # Tomar el primer valor de DeviceName en cada grupo
    'AngleX(°)': 'mean',    # Promediar los valores numéricos
    'AngleY(°)': 'mean',
    'AngleZ(°)': 'mean',
    'ACC X PROM': 'mean',
    'ACC Y PROM': 'mean',
    'ACC Z PROM': 'mean'
}).reset_index()

# Imprimir el DataFrame agrupado y promediado
print(df_promedio_por_segundoWT3)

"""AJUSTE DE ÁNGULOS"""

# Sumar 0.5 a las columnas AngleX, AngleY y AngleZ
df_promedio_por_segundoWT3['AngleX(°)'] += 0.5
df_promedio_por_segundoWT3['AngleY(°)'] += 0.5
df_promedio_por_segundoWT3['AngleZ(°)'] += 0.5

# Guardar el DataFrame modificado en un nuevo archivo CSV
df_promedio_por_segundoWT3.to_csv('tu_dataset_modificado.csv', index=False)

print("Valores actualizados en las columnas AngleX, AngleY y AngleZ:")
print(df_promedio_por_segundoWT3)

"""GRÁFICO DE ACALERACIONES EN EL TIEMPO"""

# Crear una figura de mayor tamaño
plt.figure(figsize=(20, 9))

# Graficar ACC X PROM
plt.plot(df_promedio_por_segundoWT3['Time'], df_promedio_por_segundoWT3['ACC X PROM'], label='ACC X PROM')

# Graficar ACC Y PROM
plt.plot(df_promedio_por_segundoWT3['Time'], df_promedio_por_segundoWT3['ACC Y PROM'], label='ACC Y PROM')

# Graficar ACCZ PROM
plt.plot(df_promedio_por_segundoWT3['Time'], df_promedio_por_segundoWT3['ACC Z PROM'], label='ACC Z PROM')

# Configuración de la gráfica
plt.xlabel('Time')
plt.ylabel('Value')
plt.title('ACC Promedio por segundo')
plt.legend()
plt.xticks(rotation=45)  # Rotar etiquetas del eje X para mejor visualización
plt.gca().set_xticks( df_promedio_por_segundoWT1['Time'][::5])  # Establecer marcas cada 5 segundos

# Mostrar la gráfica
plt.tight_layout()  # Ajustar márgenes
plt.show()

""" IDENTIFICACIÓN DE PERIODOS DE ACALERACIÓN E INCLINACIÓN"""

# Definir función para identificar períodos de aceleración, desaceleración e inclinación
def identificar_rangos(df_promedio_por_segundoWT3):
    acelerando = (df_promedio_por_segundoWT3['ACC X PROM'] > 0)
    desacelerando = (df_promedio_por_segundoWT3['ACC X PROM'] < 0)

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT3.loc[acelerando, 'Categoria'] = 'Acelerando'
    df_promedio_por_segundoWT3.loc[desacelerando, 'Categoria'] = 'Desaceleración'

    Derecha = (df_promedio_por_segundoWT3['AngleX(°)'] > 2)
    Izquierda = (df_promedio_por_segundoWT3['AngleX(°)'] < -2)
    Nivelado = ((df_promedio_por_segundoWT3['AngleX(°)'] >= -2) & (df_promedio_por_segundoWT3['AngleX(°)'] <= 2))

    # Etiquetar cada período con una categoría
    df_promedio_por_segundoWT3.loc[Derecha, 'GIRO'] = 'Derecha'
    df_promedio_por_segundoWT3.loc[Izquierda, 'GIRO'] = 'Izquierda'
    df_promedio_por_segundoWT3.loc[Nivelado, 'GIRO'] = 'Nivelado'
    return df_promedio_por_segundoWT3

# Aplicar la función a nuestro DataFrame
df_promedio_por_segundo_categoriasWT3 = identificar_rangos(df_promedio_por_segundoWT3)


df_promedio_por_segundo_categoriasWT3.reset_index(drop=True, inplace=True)
df_promedio_por_segundo_categoriasWT3.index =df_promedio_por_segundo_categoriasWT3.index + 1

# Mostrar el DataFrame con las categorías identificadas
print(df_promedio_por_segundo_categoriasWT3)

"""**TABLET**"""

#Importación del dataset
from google.colab import drive
drive.mount("/content/drive/")
data_2=pd.read_csv("/content/drive/MyDrive/Colab Notebooks/TABLET 60KM Mauricio prueba 3.csv")
print (data_2)

# Eliminar duplicados basados en la columna "Time"
df_sin_duplicados = data_2.drop_duplicates(subset=['Time'])

# Mostrar el DataFrame resultante
print(df_sin_duplicados)

"""FILTRACIÓN DE COLUMNAS DE INTERES"""

# Seleccionar solo las columnas deseadas
df_tablet= df_sin_duplicados.loc[:, ['Time', 'Name']]

# Mostrar el nuevo DataFrame con las columnas seleccionadas
print(df_tablet)

"""**CONCATENCIÓN DE SENSORES CON TABLET**



"""

# Restablecer el índice de ambos DataFrames
df_promedio_por_segundo_categoriasWT1.reset_index(drop=True, inplace=True)
df_tablet.reset_index(drop=True, inplace=True)

# Asegurarse de que ambos DataFrames tengan el mismo número de filas
print(len(df_promedio_por_segundo_categoriasWT1), len(df_tablet))

# Concatenar los DataFrames, manteniendo la columna 'Time' del conjunto de datos 1 y la columna 'Name' del conjunto de datos 2
df_final_WT1 = pd.concat([df_promedio_por_segundo_categoriasWT1, df_tablet['Name']], axis=1)

# Mostrar el DataFrame concatenado
print(df_final_WT1)

# Restablecer el índice de ambos DataFrames
df_promedio_por_segundo_categoriasWT2.reset_index(drop=True, inplace=True)
df_tablet.reset_index(drop=True, inplace=True)

# Asegurarse de que ambos DataFrames tengan el mismo número de filas
print(len(df_promedio_por_segundo_categoriasWT2), len(df_tablet))

# Concatenar los DataFrames, manteniendo la columna 'Time' del conjunto de datos 1 y la columna 'Name' del conjunto de datos 2
df_final_WT2 = pd.concat([df_promedio_por_segundo_categoriasWT2, df_tablet['Name']], axis=1)

# Mostrar el DataFrame concatenado
print(df_final_WT2)

# Restablecer el índice de ambos DataFrames
df_promedio_por_segundo_categoriasWT3.reset_index(drop=True, inplace=True)
df_tablet.reset_index(drop=True, inplace=True)

# Asegurarse de que ambos DataFrames tengan el mismo número de filas
print(len(df_promedio_por_segundo_categoriasWT3), len(df_tablet))

# Concatenar los DataFrames, manteniendo la columna 'Time' del conjunto de datos 1 y la columna 'Name' del conjunto de datos 2
df_final_WT3 = pd.concat([df_promedio_por_segundo_categoriasWT3, df_tablet['Name']], axis=1)

# Mostrar el DataFrame concatenado
print(df_final_WT3)

# Guardar el DataFrame como un archivo CSV
#df_final_WT1.to_csv('datos_final.csv', index=False)
# Guardar los DataFrames en un archivo Excel con hojas separadas
with pd.ExcelWriter('sensores_datasets.xlsx') as writer:
    df_final_WT1.to_excel(writer, sheet_name='WTC1', index=False)
    df_final_WT2.to_excel(writer, sheet_name='WTC2', index=False)
    df_final_WT3.to_excel(writer, sheet_name='WTC3', index=False)